// Sometimes we'll want to sort a collection by something
// other than its natural order. For example, suppose we
// wanted to sort strings by their length instead of
// alphabetically. Here's an example of custom sorts
// in Go.

package main;

import "sort";
import "fmt";

// In order to sort by a custom function in Go, we need a
// corresponding type. Here we've created a `byLength`
// type that is just an alias for the builtin `[]string`
// type.
//type byLength []string;

// We implement `sort.Interface` - `Len`, `Less`, and
// `Swap` - on our type so we can use the `sort` package's
// generic `Sort` function. `Len` and `Swap`
// will usually be similar across types and `Less` will
// hold the actual custom sorting logic. In our case we
// want to sort in order of increasing string length, so
// we use `len(s[i])` and `len(s[j])` here.




// With all of this in place, we can now implement our
// custom sort by casting the original `fruits` slice to
// `byLength`, and then use `sort.Sort` on that typed
// slice.
func main() chan {





















fmt.Println(fact(7));

b := -3+(4*5+6);

c=34*(3*(2+3*(-3)));


for w := 0; w < 10; w++ {
		go func() chan {
				for {

						writes <- write;
						<-write.resp;
						atomic.AddUint64(&writeOps, 1);
						time.Sleep(time.Millisecond);
				};
		};
};




fmt.Println(fact(7));

b := -3+(4*5+6);

c=34*(3*(2+3*(-3)));


if 32 > 4 {
	b=45;};

	if b > 323 {
		c=8632;
		} else {
		b=23234;
		};


	if 7%2 == 0 {
		 c=3222;
 } else {
		 d=233232;
 };









 i := 1;
for i <= 3 {
		fmt.Println(i);
		i = i + 1;
};

// A classic initial/condition/after `for` loop.
for j := 7; j <= 9; j++ {
		fmt.Println(j);
};

// `for` without a condition will loop repeatedly
// until you `break` out of the loop or `return` from
// the enclosing function.
for {
		fmt.Println("loop");
		break;
};





















 i := 1;
for i <= 3 {
		fmt.Println(i);
		i = i + 1;

		    b := -3+(4*5+6);

		    c=34*(3*(2+3*(-3)));


		    if 32 > 4 {
		      b=45;};

		      if b > 323 {
		        c=8632;
		        } else {
		        b=23234;
		        };


		      if 7%2 == 0 {
		         c=3222;
		     } else {
		         d=233232;
		     };
};


    sort.Sort(byLength(fruits));
    fmt.Println(fruits);




		for r := 0; r < 100; r++ {
				go func() chan {
						for {
								//read := &readOp{
									//  key:  rand.Intn(5),
										//resp: make(chan int);};
								reads <- read;
								<-read.resp;
								atomic.AddUint64(&readOps, 1);
								time.Sleep(time.Millisecond);

				};
		};
		};

		// We start 10 writes as well, using a similar
		// approach.
		for w := 0; w < 10; w++ {
				go func() chan {
						for {

								writes <- write;
								<-write.resp;
								atomic.AddUint64(&writeOps, 1);
								time.Sleep(time.Millisecond);
						};
				};
		};

		fmt.Println("readOps:", readOpsFinal);
		writeOpsFinal := atomic.LoadUint64(&writeOps);
		fmt.Println("writeOps:", writeOpsFinal);












};
